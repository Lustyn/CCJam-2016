local args = { ... }

local flags = {
    ["eyes"] = "Changes cow's eyes. Aliases: e, eyes",
    ["tongue"] = "Changes cow's tongue. Aliases: t, tongue",
    ["thoughts"] = "Changes cow's thoughtbubble lines. Aliases: T, thoughts",
    ["think"] = "Changes if cow is thinking or not. Aliases: q, think",
    ["download"] = "Downloads a cow file. Aliases: d, dl, download",
    ["output"] = "Outputs to a file or changes file output. Aliases: o, out, output",
    ["cow"] = "Chooses which cow file to load. Aliases: f, file, cow, c"
}
function printHelp()
    print("Usage: "..shell.getRunningProgram().." [text] [-flag [string]]")
    print("Flags: ")
    for i,v in pairs(flags) do
        print(i..": "..v)
    end
end

if #args < 1 then
    printHelp()
    return
end

-- CONSTANTS
local cow_begin = "<<EOC;\n"
local cow_begin_alt = "<<\"EOC\";\n"
local cow_end = "\nEOC"
local cow_vars = {
    "thoughts",
    "eyes",
    "tongue"
}
local cow_vars_defaults = {
    ["thoughts"] = "\\",
    ["eyes"] = "oo",
    ["tongue"] = "  "
}

local function parseArgs(args)
    local current = 0
    local pargs = {}
    local tripped = false
    local pargs = {}
    local adding = false
    local addto = ""
    for i=1,#args do
        if args[i+1] and args[i]:sub(1,1) == "-" then
            tripped = true
            if args[i+1]:sub(1,1) == "-" then
                pargs[args[i]:sub(2)] = true
            elseif args[i+1]:sub(1,1) ~= "\"" then
                pargs[args[i]:sub(2)] = args[i+1]
            end
        elseif args[i+1] and args[i+1]:sub(1,1) == "\"" then
            adding = true
            addto = pargs[args[i]:sub(2)]
            pargs[args[i]:sub(2)] = ""
        elseif adding then
            if args[i]:sub(-1) == "\"" then
                adding = false
            end
            pargs[addto] = pargs[addto].." ".. args[i]
        elseif not tripped then
            pargs["text"] = (pargs["text"] or "").." "..args[i]
        end
    end
    if pargs["text"] and pargs["text"]:sub(1,1) == " " then
        pargs["text"] = pargs["text"]:sub(2)
    end
    return pargs
end

function split(str, pat)
   local t = {}  -- NOTE: use {n = 0} in Lua-5.0
   local fpat = "(.-)" .. pat
   local last_end = 1
   local s, e, cap = str:find(fpat, 1)
   while s do
      if s ~= 1 or cap ~= "" then
	 table.insert(t,cap)
      end
      last_end = e+1
      s, e, cap = str:find(fpat, last_end)
   end
   if last_end <= #str then
      cap = str:sub(last_end)
      table.insert(t, cap)
   end
   return t
end

local function replaceVar(cow, var, data)
    return cow:gsub("$"..var, data)
end

local function max(linez)
    local m = 0
    for i, v in pairs(linez) do
        if v:len() > m then
            m = v:len()
        end
    end
    return m
end

local function lines(str)
  local t = {}
  local function helper(line) table.insert(t, line) return "" end
  helper((str:gsub("(.-)\r?\n", helper)))
  return t
end

local function pad(text, length)
	return text..string.rep(" ", length - text:len())
end

local function top(length)
    return string.rep("_", length+2)
end

local function bottom(length, p)
    return string.rep("-", length+2)
end

local function formatBubbleText(text, delimiters)
    local linez = lines(text)
    local m = max(linez)
    local balloon = ""
    local delim = {}
    if #linez == 1 then
        balloon = " "..top(m).."\n"..delimiters.only[1].." "..linez[1].." "..delimiters.only[2].."\n".." "..bottom(m).."\n"
    else
        balloon = " "..top(m).."\n"
        for i,v in ipairs(linez) do
            if i==1 then
                delim = delimiters["first"]
            elseif i==#linez then
                delim = delimiters["last"]
            else
                delim = delimiters["middle"]
            end
            balloon = balloon..delim[1].." "..pad(v, m).." "..delim[2].."\n"
        end
        balloon = balloon.." "..bottom(m).."\n"
    end
    return balloon
end

local function say(text)
    local delimiters = {
        first = {"/", "\\"},
        middle = {"|", "|"},
        last = {"\\", "/"},
        only = {"<", ">"},
    }

    return formatBubbleText(text, delimiters)
end

local function think(text)
    local delimiters = {
        first = {"(", ")"},
        middle = {"(", ")"},
        last = {"(", ")"},
        only = {"(", ")"},
    }

    return formatBubbleText(text, delimiters)
end

local function readCow(cow)
    if cow:find(cow_begin_alt) then
        cow = cow:gsub(cow_begin_alt, cow_begin)
    end
    local _, start = cow:find(cow_begin)
    local stop, _ = cow:find(cow_end)
    cow = cow:sub(start, stop)
    return cow:sub(2)
end

local function getCowVars(cow)
    local vars = {}
    for k, v in pairs(cow_vars) do
        if cow:find("$"..v) then
            vars[v] = true
        else
            vars[v] = false
        end
    end
    return vars
end

local function formatCow(cow, options)
    if not options then
        options = {}
    end
    local cow = readCow(cow):gsub("\\\\","\\"):gsub("\\@","@"):gsub("\\$","$")
    local vars = getCowVars(cow)
    for k, v in pairs(vars) do
        if options[k] then
            if k == "tongue" and options[k]:len() < 2 then
                options[k] = options[k].." "
            end
            cow = replaceVar(cow, k, options[k])
        else
            cow = replaceVar(cow, k, cow_vars_defaults[k])
        end
    end
    return cow
end

function makeCow(cow, text, options, think)
    if think then
        return think(text)..formatCow(cow, options)
    else
        return say(text)..formatCow(cow, options)
    end
end

function makeCowFromFile(file, text, options, think)
    if not fs.exists(file) and not fs.isDir(file) then
        file = "/cows/"..file
    end
    if fs.exists(file) and not fs.isDir(file) then
        local fi = fs.open(file, "r")
        local cow = fi.readAll()
        fi.close()
        return makeCow(cow, text, options, think)
    else
        error("File does not exist or is a directory.")
    end
end

function downloadCow(url)
    if not http.checkURL(url) then
        error("Invalid URL")
    else
        local req = http.get(url)
        if req then
            local cow = req.readAll()
            req.close()
            return cow
        else
            error("Download failed.")
        end
    end
end

function downloadCowToFile(url, file)
    local cow = downloadCow(url)
    local fi = fs.open(file, "w")
    fi.write(cow)
    fi.close()
end

function downloadCowList()
    --TODO
end

function listCows()
    --TODO
end

function listDownloadedCows()
    --TODO
end

local pArgs = parseArgs(args)
local options = {
    eyes = pArgs["e"] or pArgs["eyes"] or nil,
    tongue = pArgs["t"] or pArgs["tongue"] or nil,
    thoughts = pArgs["T"] or pArgs["thoughts"] or nil,
}
local think = pArgs["q"] or pArgs["think"] or false
local cow_file = pArgs["c"] or pArgs["cow"] or pArgs["f"] or pArgs["file"] or nil
if (pArgs["d"] and type(pArgs["d"]) == "string") or (pArgs["download"] and type(pArgs["download"]) == "string") or (pArgs["dl"] and type(pArgs["dl"]) == "string") then
    local filename
    if pArgs["o"] or pArgs["out"] or pArgs["output"] then
        filename = pArgs["o"] or pArgs["out"] or pArgs["output"]
    else
        local parts = split(pArgs["d"],"/")
        filename = parts[#parts]
    end
    downloadCowToFile(pArgs["d"], filename)
    print("Downloaded "..filename)
elseif pArgs["text"] and pArgs["text"]:len() > 0 then
    if cow_file == nil then
        cow_file = "default.cow"
    end
    print(makeCowFromFile(cow_file, pArgs["text"], options, think))
else
    printHelp()
    return
end